package vault

import (
	"encoding/json"

	"github.com/kelda/kelda/db"
	"github.com/kelda/kelda/join"

	log "github.com/sirupsen/logrus"
)

// A vaultPolicy is a description of what paths clients are allowed to
// manipulate. Every client has at least one policy associated with it.
// For more about policies and their role in the overall Vault structure, refer
// to vault.go.
type vaultPolicy struct {
	// The policy name is used by authentication backends to refer to the
	// policies that should be associated with a client once it authenticates.
	name string

	// The policy is a JSON object describing what paths the client is allowed
	// to manipulate.
	// For example, the following policy allows read access to /canRead, and
	// write access to /canWrite.
	// {
	//   "path": {
	//     "/canRead": {
	//       "policy":"read"
	//     },
	//     "/canWrite": {
	//       "policy":"write"
	//     }
	//   }
	// }
	policy string
}

func syncPolicies(client APIClient, conn db.Conn) {
	currentPolicies, err := getCurrentPolicies(client)
	if err != nil {
		log.WithError(err).Error("Failed to list current Vault policies")
		return
	}

	joinPolicies(client, getDesiredPolicies(conn), currentPolicies)
}

func joinPolicies(client APIClient, desiredPolicies, currentPolicies vaultPolicySlice) {
	_, toAdd, toDel := join.HashJoin(desiredPolicies, currentPolicies, nil, nil)

	for _, intf := range toAdd {
		policy := intf.(vaultPolicy)
		err := client.PutPolicy(policy.name, policy.policy)
		if err != nil {
			log.WithFields(log.Fields{
				"error":  err,
				"policy": policy,
			}).Error("Failed to put Vault policy")
		}
	}

	for _, intf := range toDel {
		policy := intf.(vaultPolicy)
		err := client.DeletePolicy(policy.name)
		if err != nil {
			log.WithFields(log.Fields{
				"error":  err,
				"policy": policy,
			}).Error("Failed to delete Vault policy")
		}
	}
}

// getDesiredPolicies returns the policies necessary for the Kelda minions
// to interact with Vault. Specifically, it allows masters to write to Vault,
// and it grants workers read access to the secrets they need in order to boot
// their scheduled containers. The policies may change as containers are
// rescheduled, or new masters are booted.
func getDesiredPolicies(conn db.Conn) (desiredPolicies []vaultPolicy) {
	// Assign all master minions a policy that allows them to write to any
	// secret.
	writeAllPolicy := policyString(map[string]string{"*": "write"})
	for _, m := range conn.SelectFromMinion(nil) {
		if m.Role == db.Master {
			desiredPolicies = append(desiredPolicies, vaultPolicy{
				name:   m.PrivateIP,
				policy: writeAllPolicy,
			})
		}
	}

	// Process the scheduled containers to decide what minions should be allowed
	// to read which secrets.
	workerToSecrets := map[string][]string{}
	scheduledContainers := conn.SelectFromContainer(func(dbc db.Container) bool {
		return dbc.Minion != ""
	})
	for _, c := range scheduledContainers {
		workerToSecrets[c.Minion] = append(workerToSecrets[c.Minion],
			c.GetReferencedSecrets()...)
	}

	for worker, secretNames := range workerToSecrets {
		acls := map[string]string{}
		for _, secretName := range secretNames {
			acls[secretName] = "read"
		}
		desiredPolicies = append(desiredPolicies, vaultPolicy{
			name:   worker,
			policy: policyString(acls),
		})
	}

	return desiredPolicies
}

// getCurrentPolicies returns the policies currently configured in Vault.
func getCurrentPolicies(client APIClient) (policies []vaultPolicy, err error) {
	names, err := client.ListPolicies()
	if err != nil {
		return nil, err
	}

	for _, name := range names {
		// The default and root policies are generated by Vault, and ignored by
		// Kelda.
		if name == "default" || name == "root" {
			continue
		}

		policyStr, err := client.GetPolicy(name)
		if err != nil {
			return nil, err
		}

		policies = append(policies, vaultPolicy{name, policyStr})
	}

	return policies, err
}

// policyString returns the Vault JSON policy representing the given acls. It
// automatically converts the secret name to the actual path needed for the
// vault.SecretStore methods to work.
// `acls` maps a secret name to the allowed operations for that secret. For
// example {"secret": "read"} gives read permissions for the secret "secret".
func policyString(acls map[string]string) string {
	formattedACLs := map[string]interface{}{}
	for secretName, acl := range acls {
		formattedACLs[pathForSecret(secretName)] = map[string]string{
			"policy": acl,
		}
	}
	policy := map[string]interface{}{
		"path": formattedACLs,
	}
	marshalled, _ := json.Marshal(policy)
	return string(marshalled)
}

type vaultPolicySlice []vaultPolicy

// Get returns the value contained at the given index
func (slc vaultPolicySlice) Get(i int) interface{} {
	return slc[i]
}

// Len returns the number of items in the slice.
func (slc vaultPolicySlice) Len() int {
	return len(slc)
}
